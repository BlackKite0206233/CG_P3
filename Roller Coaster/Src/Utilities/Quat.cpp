#include "Utilities/Quat.h"

//*****************************************************************************
//
// Minimal Quaternion Class - if you don't know what a quaternion is, don't
// worry. if you do know what a quaternion is, you probably want a more complete
// implementation
//
//*****************************************************************************

//**************************************************************************
//
// * Set up constructor
//==========================================================================
Quat::Quat(float ix, float iy, float iz, float iw) : x(ix), y(iy), z(iz), w(iw)
//==========================================================================
{
}

//**************************************************************************
//
// * Default constructor
//==========================================================================
Quat::Quat() : x(0), y(0), z(0), w(1)
//==========================================================================
{
}

//**************************************************************************
//
// * Copy constructor
//==========================================================================
Quat::Quat(const Quat &q) : x(q.x), y(q.y), z(q.z), w(q.w)
//==========================================================================
{
}

//**************************************************************************
//
// * Renormalize, in case things got messed up
//==========================================================================
void Quat::renorm()
//==========================================================================
{
	float Nq = 1.f / (float)sqrt(x * x + y * y + z * z + w * w);
	x *= Nq;
	y *= Nq;
	z *= Nq;
	w *= Nq;
}

//**************************************************************************
//
// * Conversions to a 4x4 matrix
//==========================================================================
void Quat::toMatrix(HMatrix out) const
//==========================================================================
{
	float Nq = x * x + y * y + z * z + w * w;
	float s = (Nq > 0.f) ? (2.0f / Nq) : 0.f;
	float xs = x * s, ys = y * s, zs = z * s;
	float wx = w * xs, wy = w * ys, wz = w * zs;
	float xx = x * xs, xy = x * ys, xz = x * zs;
	float yy = y * ys, yz = y * zs, zz = z * zs;
	out[X][X] = 1.0f - (yy + zz);
	out[Y][X] = xy + wz;
	out[Z][X] = xz - wy;
	out[X][Y] = xy - wz;
	out[Y][Y] = 1.0f - (xx + zz);
	out[Z][Y] = yz + wx;
	out[X][Z] = xz + wy;
	out[Y][Z] = yz - wx;
	out[Z][Z] = 1.0f - (xx + yy);
	out[X][W] = out[Y][W] = out[Z][W] = out[W][X] = out[W][Y] = out[W][Z] = 0.0f;
	out[W][W] = 1.0f;
}

//**************************************************************************
//
// * Find the conjugate of the quaternion
//==========================================================================
Quat Quat::conjugate() const
//==========================================================================
{
	return Quat(-x, -y, -z, w);
}

//**************************************************************************
//
// *
//==========================================================================
Quat Quat::operator*(const Quat &qR) const
//==========================================================================
{
	Quat qq;
	qq.w = w * qR.w - x * qR.x - y * qR.y - z * qR.z;
	qq.x = w * qR.x + x * qR.w + y * qR.z - z * qR.y;
	qq.y = w * qR.y + y * qR.w + z * qR.x - x * qR.z;
	qq.z = w * qR.z + z * qR.w + x * qR.y - y * qR.x;
	return (qq);
}
